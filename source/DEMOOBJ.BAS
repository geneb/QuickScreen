'***************  DemoOBJ.Bas  -  Demo Data Entry without external files.

' Copyright (c) 1991 Crescent Software
' Written by Don Malin

' This program demonstrates calling an Object screen and using the DATA
' statements generated by QSCR.EXE (.DTA) to initialize the field information
' arrays.  An executable version of this program would not require any
' external files at runtime.

' Before you can run this demonstration program, you must create a custom
' Quick Library containing the "Object" screen ALLTYPES.OBJ.  To do this, use
' the MAKEQLB.EXE program as follows:
'
' For QuickBASIC 4.5:
'   >MAKEQLB DEMOOBJ ALLTYPES.OBJ,,,FORMS,BQLB45
'
' For BASIC 7.X PDS:
'   >MAKEQLB DEMOOBJ ALLTYPES.OBJ,,,FORMS7,QBXQLB
'
' After MAKEQLB has finished, start QB, or QBX as follows:
'
'   >QB DEMOOBJ /L DEMOOBJ
'***************************************************************************


DEFINT A-Z

'-------- Declarations
DECLARE FUNCTION Monitor% ()
DECLARE SUB DisplayScrn (BTmp%(), Element%, MonoCode%, WipeType%)
DECLARE SUB EditForm (Form$(), Fld() AS ANY, Frm AS ANY, Cnf AS ANY, Action)
DECLARE SUB Tokenize (Calc$, Fld() AS ANY)

'-------- Type and constant definitions

'   $INCLUDE: 'FieldInf.bi'                     'FieldInfo type & constants
'   $INCLUDE: 'FormEdit.bi'                     'FormInfo type & constants
'   $INCLUDE: 'DefCnf.bi'                       'Config type
'   $INCLUDE: 'SetCnf.bi'                       'init config variables

'-------- Init Type Variables

    DIM Frm AS FormInfo                         'FormInfo type variable

'-------- Turn the mouse cursor on
    CLS

    CALL TextCursor(-2, -2)                     'Define the Mouse cursor
    CALL ShowCursor

'-------- Set MonoCode according to monitor type or command line switch /B

    MonoCode = ABS(PEEK(&H463) = &HB4 OR INSTR(COMMAND$, "/B")) * 3

'-------- Display our object screen using a wipe type.
    REDIM Scrn(2002)                            'Holds old and new screen
    CALL MScrnSave(1, 1, 25, 80, SEG Scrn(2))   'Save the old screen

    CALL AllTypes(WipeType, SEG Scrn(2))        'Overlay new screen into array
   
    '----- Specify the size of the screen in the array
    Scrn(0) = 1 * 256 + 1                       'Upper left corner
    Scrn(1) = 80 * 256 + 25                     'Lower right corner

    DisplayScrn Scrn(), 0, MonoCode, WipeType   'Display the screen


'****************************************************************************
'* The following code is used to set up field definitions from DATA
'* statements instead of from a disk file.  You can use this same code for
'* any form but you must change the two RESTORE statement labels and the
'* INCLUDE file name to the name used for your form.
'****************************************************************************

    '----- Include the DATA statement file generated for our form
    '$INCLUDE: 'AllTypes.DTA'

    '----- Set the READ pointer to start reading the ALLTYPES DATA statements
    RESTORE ALLTYPES.FieldInfo

    '----- First DATA item is the number of fields for the form
    READ NumFlds

    '----- Create the field information array
    REDIM Fld(NumFlds) AS FieldInfo
    '----- Create the form data array
    REDIM Form$(NumFlds, 2)

    '----- Restore the READ pointer since we moved it above
    RESTORE ALLTYPES.FieldInfo

    '----- Read the field definitions for each field
    FOR N = 0 TO NumFlds
       READ Fld(N).Fields
       READ Fld(N).Row
       READ Fld(N).LCol
       READ Fld(N).RCol
       READ Fld(N).StorLen
       READ Fld(N).FType
       READ Fld(N).RelFile
       READ Fld(N).RelFld
       READ Fld(N).Indexed
       READ Fld(N).FldName
       READ Fld(N).Decimals
       READ Fld(N).RelHandle
       READ Fld(N).Protected
       READ Fld(N).ScratchI
       READ Fld(N).LowRange
       READ Fld(N).HiRange
       READ Fld(N).ScratchS
    NEXT

    '----- Read Help messages
    FOR N = 0 TO NumFlds
       READ Form$(N, 1)
       CALL ReplaceChar(Form$(N, 1), "'", CHR$(34))
    NEXT

    '----- Read formulas for calculated fields
    FOR N = 0 TO NumFlds
       READ Form$(N, 2)
      
       IF LEN(Form$(N, 2)) THEN         'Replace single quotes with doubles
          CALL ReplaceChar(Form$(N, 2), "'", CHR$(34))
          Tokenize Form$(N, 2), Fld()   'Make formulas readable by "QSCalc"
       END IF
    NEXT

    '----- Set up some sample multiple choice elements
    REDIM Choice$(26, 0)                                 'multi choice array
    Choice$(0, 0) = "6"
    FOR N = 1 TO 26
       Choice$(N, 0) = CHR$(N + 64) + " Choice"
    NEXT


'-------- Edit the form
    Action = 1

    DO                                                  'inside a loop
        EditForm Form$(), Fld(), Frm, Cnf, Action       'check for keypress
                                                        'and handle if needed
    LOOP UNTIL Frm.KeyCode = 27 OR Frm.KeyCode = -60    'loop until escape or
                                                        '  F2 pressed
'-------- That's it folks

    END

